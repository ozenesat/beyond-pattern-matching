# sequences.yaml
# Ordered curriculum for hierarchical motif discovery and reuse.

tasks:
  # ===== L1: Primitives-only behaviors (no loop needed except drain) =====
  - name: drain
    expected_level: 1
    primers: [1, 2, 3]
    horizon: 8
    # Goal: force "drain-in-place" (clear entry cell). Minimal loop motif '[-]' should emerge.
    sequences:
      - [1, 0, 0, 0, 0, 0, 0, 0]
      - [2, 0, 0, 0, 0, 0, 0, 0]
      - [3, 0, 0, 0, 0, 0, 0, 0]

  - name: copy
    expected_level: 1
    primers: [1, 2, 3]
    horizon: 8
    # Goal: output should equal input at every step (identity transducer).
    sequences:
      - [1, 1, 1, 1, 1, 1, 1, 1]
      - [2, 2, 2, 2, 2, 2, 2, 2]
      - [3, 3, 3, 3, 3, 3, 3, 3]

  - name: increment
    expected_level: 1
    primers: [1]
    horizon: 8
    # Goal: x_{t+1} = x_t + 1 (arithmetic successor). Trivial sanity check.
    sequences: [1, 2, 3, 4, 5, 6, 7, 8]

  - name: decrement
    expected_level: 1
    primers: [8]
    horizon: 8
    # Goal: x_{t+1} = x_t - 1 (mod 256). Trivial sanity check.
    sequences: [8, 7, 6, 5, 4, 3, 2, 1]

  - name: add_two
    expected_level: 1
    primers: [1, 2, 3]
    horizon: 8
    # Goal: x_{t+1} = x_t + 2 for multiple primers.
    sequences:
      - [1, 3, 5, 7, 9, 11, 13, 15]
      - [2, 4, 6, 8, 10, 12, 14, 16]
      - [3, 5, 7, 9, 11, 13, 15, 17]

  - name: add_3
    expected_level: 1
    primers: [1, 2, 3]
    horizon: 7
    # Goal: x_{t+1} = x_t + 3 for multiple primers.
    sequences:
      - [1, 4, 7, 10, 13, 16, 19]
      - [2, 5, 8, 11, 14, 17, 20]
      - [3, 6, 9, 12, 15, 18, 21]

  # ===== L2: Simple controllers (repeaters, oscillators, small cycles) =====
  - name: repeat_2
    expected_level: 2
    primers: [1, 2, 3]
    horizon: 8
    # Goal: repeat each value twice (x, x, x+1, x+1, ...). Tends to elicit a tiny toggle/state bit.
    sequences:
      - [1, 1, 2, 2, 3, 3, 4, 4]
      - [2, 2, 3, 3, 4, 4, 5, 5]
      - [3, 3, 4, 4, 5, 5, 6, 6]

  - name: repeat_3
    expected_level: 2
    primers: [1, 2, 3]
    horizon: 9
    # Goal: repeat each value three times. Requires a 3-state micro-controller.
    sequences:
      - [1, 1, 1, 2, 2, 2, 3, 3, 3]
      - [2, 2, 2, 3, 3, 3, 4, 4, 4]
      - [3, 3, 3, 4, 4, 4, 5, 5, 5]

  - name: oscillator
    expected_level: 2
    primers: [1, 2, 3]
    horizon: 8
    # Goal: x alternates between two values; encourages pointer oscillation + reset.
    sequences:
      - [1, 3, 1, 3, 1, 3, 1, 3]
      - [2, 4, 2, 4, 2, 4, 2, 4]
      - [3, 5, 3, 5, 3, 5, 3, 5]

  - name: modular_cycle
    expected_level: 2
    primers: [1]
    horizon: 9
    # Goal: cycle through 1,2,3; requires short-period controller.
    sequences: [1, 2, 3, 1, 2, 3, 1, 2, 3]

  - name: alternating_step
    expected_level: 2
    primers: [1]
    horizon: 8
    # Goal: steps +2, +4 alternating: 1,3,7,9,...
    sequences: [1, 3, 7, 9, 13, 15, 19, 21]

  - name: growing_step
    expected_level: 2
    primers: [1]
    horizon: 8
    # Goal: step size increases by 1 each time: +1, +2, +3, ...
    sequences: [1, 2, 4, 7, 11, 16, 22, 29]

  - name: parity_dependent_step
    expected_level: 2
    primers: [1]
    horizon: 14
    # Goal: if x_t even → +1, else → +3; needs parity gate.
    sequences: [1, 4, 5, 6, 9, 10, 11, 14, 15, 16, 19, 20, 21]

  # ===== L3: Counting loops and affine transforms =====
  - name: doubling
    expected_level: 3
    primers: [1]
    horizon: 8
    # Goal: x_{t+1} = 2*x_t ; requires a true counting loop each step.
    sequences: [1, 2, 4, 8, 16, 32, 64, 128]

  - name: tripling
    expected_level: 3
    primers: [1]
    horizon: 6
    # Goal: x_{t+1} = 3*x_t ; even harder counting loop each step.
    sequences: [1, 3, 9, 27, 81, 243]

  - name: double_add_1
    expected_level: 3
    primers: [1]
    horizon: 7
    # Goal: x_{t+1} = 2*x_t + 1 ; composition of counting + bias.
    sequences: [1, 3, 7, 15, 31, 63, 127]

  - name: every_3rd_double
    expected_level: 3
    primers: [1, 2, 3]
    horizon: 9
    # Goal: +1 normally; *2 on steps 3,6,9... (mod-3 controller + counting loop).
    sequences:
      - [1, 2, 3, 6, 7, 8, 16, 17, 18]
      - [2, 3, 4, 8, 9, 10, 20, 21, 22]
      - [3, 4, 5, 10, 11, 12, 24, 25, 26]

  - name: increment_then_double
    expected_level: 3
    primers: [1]
    horizon: 8
    # Goal: x_{t+1} = 2*(x_t+1)
    sequences: [1, 4, 10, 22, 46, 94, 190, 382]

  - name: double_then_add_two
    expected_level: 3
    primers: [1]
    horizon: 8
    # Goal: x_{t+1} = 2*x_t + 2
    sequences: [1, 4, 10, 22, 46, 94, 190, 382]

  - name: increment_if_even_else_double
    expected_level: 3
    primers: [1, 2, 3]
    horizon: 8
    # Goal: parity gate + counting loop.
    sequences:
      - [1, 2, 4, 5, 10, 11, 22, 23]
      - [2, 3, 6, 7, 14, 15, 30, 31]
      - [3, 6, 7, 14, 15, 30, 31, 62]

  - name: two_state_accumulator
    expected_level: 3
    primers: [1]
    horizon: 8
    # Goal: keep y; x_{t+1} = x_t + y_t ; y_{t+1} = x_t (Fibonacci-like).
    sequences: [1, 2, 3, 5, 8, 13, 21, 34]

  - name: linear_with_aux_counter
    expected_level: 3
    primers: [1]
    horizon: 9
    # Goal: x_{t+1} = x_t + c_t ; c_{t+1} = c_t + 1 ; starts c0=1.
    sequences: [1, 2, 4, 7, 11, 16, 22, 29]

  - name: alternate_add_and_double
    expected_level: 3
    primers: [1]
    horizon: 8
    # Goal: +2, then *2, repeat.
    sequences: [1, 3, 6, 12, 14, 28, 30, 60]

  - name: mod3_cycle_then_reset
    expected_level: 3
    primers: [1]
    horizon: 16
    # Goal: +3 until ≥30, then reset to 0; repeat window (controller + reset).
    sequences: [1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 0, 3, 6, 9, 12, 15]

  - name: gated_double_every_4th
    expected_level: 3
    primers: [1, 2]
    horizon: 10
    # Goal: *2 every 4th step, +1 otherwise (periodic gate + counting).
    sequences:
      - [1, 2, 3, 4, 8, 9, 10, 11, 22, 23]
      - [2, 3, 4, 5, 10, 11, 12, 13, 26, 27]

  - name: double_or_add_two_by_threshold
    expected_level: 3
    primers: [1]
    horizon: 12
    # Goal: if x<40 then *2 else +2 (piecewise transform).
    sequences: [1, 2, 4, 8, 16, 32, 34, 36, 38, 40, 42, 44]

  - name: affine_double_plus_one_multi
    expected_level: 3
    primers: [1, 2, 3]
    horizon: 7
    # Goal: x_{t+1} = 2*x_t + 1 for multiple primers (forces mechanism).
    sequences:
      - [1, 3, 7, 15, 31, 63, 127]
      - [2, 5, 11, 23, 47, 95]
      - [3, 7, 15, 31, 63, 127]

  # ===== L4: Hierarchical controllers (multi-window gates, nested counters) =====
  - name: every_2_then_every_3
    expected_level: 4
    primers: [1]
    horizon: 12
    # Goal: +1 for 2 steps, then +2 for 3 steps, repeat (2→3 window).
    sequences: [1, 2, 3, 5, 7, 8, 9, 11, 13, 14, 15, 17]

  - name: multi_window_sawtooth_5_8
    expected_level: 4
    primers: [1]
    horizon: 20
    # Goal: +5 until ≥35 then reset; then +8 until ≥64 then reset; alternate windows.
    sequences: [1, 6, 11, 16, 21, 26, 31, 36, 0, 8, 16, 24, 32, 40, 48, 56, 64, 0, 5, 10]

  - name: staircase_reset_10
    expected_level: 4
    primers: [1]
    horizon: 14
    # Goal: +1×3 steps, +2×3 steps, +3×3 steps, then reset to 0; repeat.
    sequences: [1, 2, 3, 5, 7, 9, 12, 15, 18, 0, 1, 2, 4, 6]

  - name: mod2_then_mod3_gate
    expected_level: 4
    primers: [1]
    horizon: 12
    # Goal: if t mod 2 == 0 then +1; if t mod 3 == 0 then *2; else +2 (multi-gate).
    sequences: [1, 3, 4, 8, 10, 11, 23, 24, 26, 28, 29, 59]

  - name: parity_then_threshold_gate
    expected_level: 4
    primers: [1]
    horizon: 12
    # Goal: if even -> +1; else if x<20 -> *2; else -> +2 (nested conditions).
    sequences: [1, 2, 4, 6, 7, 14, 16, 18, 20, 22, 24, 26]